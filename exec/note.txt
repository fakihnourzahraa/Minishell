ok in main we see if the cmnd is builting ,if it is buiktin we call it execute_builtin,if is not we call execute single
if is it a single cmnd we see if it is builtin or not 
if it is not single we see pipeline
─ For each command in pipeline:
│               └─ execute_child_process() → check builtin
│                   ├─ Builtin → execute_builtin()
│                   └─ External → get_cmd_path() + execve()


inside excute single :Builtin + No Redirections → execute_builtin()
                     : Builtin + With Redirections → execute_builtin_with_redirect()
                     : External → execute_external_command()

so fct is_buitlin only return the enum of the builtin
.execute_single :If the command is a builtin, it executes it directly (or inside a fork if there are redirections).
If it’s not a builtin, it returns 0, meaning "not handled here → let the execve path handle it".
.!cmd::pointer itself is NULL,If this is NULL and you try to access cmd->args, the program would segfault.
.!cmd->args:Checks if the args array inside the command struct is NULL
.!cmd->args[0]:Checks if the first string inside the args array is NULL
!cmd → the cmd structure itself is missing.
!cmd->args → the array of arguments is missing.
!cmd->args[0] → the array exists, but the first argument (the command name) is missing.
